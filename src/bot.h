#ifndef BOT
#define BOT

#include "template.h"

// Policy, act_0, act_1 \in [-1,7], -2 represents for empty policy
class Policy {
   public:
    int act_0, act_1;

    Policy() {}
    Policy(int act_0, int act_1) : act_0(act_0), act_1(act_1) {}

    bool operator<(const Policy &rhs) const { return (act_0 < rhs.act_0) || (act_0 == rhs.act_0 && act_1 < rhs.act_1); }

    bool operator==(const Policy &rhs) const { return act_0 == rhs.act_0 && act_1 == rhs.act_1; }

    bool empty() const { return act_0 == -2; }
};

// Monte-Carlo Tree Search, nodes are generated by both sides' policies
class Node {
   public:
    int vis, size;
    std::pair<double, double> val;
    Node *fa, *bstCh;
    std::map<std::pair<Policy, Policy>, Node *> ch;
    int dep;
    // first for Blue, second for Red
    std::pair<Policy, Policy> pol;
    bool full;

    Node(const std::pair<Policy, Policy> pol, Node *fa = nullptr)
        : vis(0), size(1), val(0.0, 0.0), fa(fa), bstCh(nullptr), dep(fa ? fa->dep + 1 : 0), pol(pol), full(false) {}

    ~Node() {
        for (auto &p : ch) delete p.second;
    }

    int CountSize() {
        size = sizeof *this;
        for (auto &p : ch) size += p.second->CountSize();
        return size;
    }

    Node *NewChild(const std::pair<Policy, Policy> &pol) { return ch[pol] = new Node(pol, this); }

    void DelFather() {
        fa->ch[pol] = nullptr;
        delete fa;
        fa = nullptr;
    }
};

class Bot {
   public:
    TankGame::TankField state;
    // parameter
    const double TIME_LIMIT;
    const double C, dist_c, rule_c, shoot_c, noteff_shoot_c, self_kill_c;
    const int rollOut;
    const int TRAIN_UNIT = 100;

    // notice that the policy is in [-1,7], so we should +1 in the following
    double val[9][9][2];
    int vis[9][9][2];
    unsigned long long timing;
    Node *root;

    Bot(const TankGame::TankField &s,
        double C = 0.9,
        double dist_c = 0.1,
        double rule_c = 0.2,
        double shoot_c = 0.2,
        double noteff_shoot_c = 0.2,
        double self_kill_c = 0.2,
        int rollOut = 5)
        : state(s),
          TIME_LIMIT(0.9),
          C(C),
          dist_c(dist_c),
          rule_c(rule_c),
          shoot_c(shoot_c),
          noteff_shoot_c(noteff_shoot_c),
          self_kill_c(self_kill_c),
          rollOut(rollOut) {
        root = new Node(std::make_pair(Policy(-2, -2), Policy(-2, -2)));
    }
    ~Bot() { delete root; }

    void Update(Node *);

    bool IsFullyExpanded(Node *);

    void Move(const std::pair<Policy, Policy> &);

    Node *RandomMove(Node *);

    void BackPropagation(Node *, const std::pair<double, double> &);

    void RollOut(Node *);

    bool MCTS();

    int Train();

    Policy GenDecision(bool);

    void Play(const std::pair<Policy, Policy> &);

    std::pair<double, double> Eval(Node *, TankGame::TankField &s);

    std::pair<double, double> Penalty(Node *, TankGame::TankField &s);
};

#endif